diff --git a/src/ObjectFactory.cpp b/src/ObjectFactory.cpp
index 64903b3304..167a86f3c1 100644
--- a/src/ObjectFactory.cpp
+++ b/src/ObjectFactory.cpp
@@ -97,7 +97,7 @@ IcePy::ObjectFactory::create(const string& id)
     //
     // Instantiate the object.
     //
-    PyTypeObject* type = reinterpret_cast<PyTypeObject*>(info->pythonType.get());
+    PyTypeObject* type = reinterpret_cast<PyTypeObject*>(info->pythonType);
     PyObjectHandle args = PyTuple_New(0);
     PyObjectHandle obj = type->tp_new(type, args.get(), 0);
     if(!obj.get())
diff --git a/src/Operation.cpp b/src/Operation.cpp
index 0eef27793d..c4f75c2995 100644
--- a/src/Operation.cpp
+++ b/src/Operation.cpp
@@ -1771,7 +1771,7 @@ IcePy::TypedInvocation::validateException(PyObject* ex) const
 {
     for(ExceptionInfoList::const_iterator p = _op->exceptions.begin(); p != _op->exceptions.end(); ++p)
     {
-        if(PyObject_IsInstance(ex, (*p)->pythonType.get()))
+        if(PyObject_IsInstance(ex, (*p)->pythonType))
         {
             return true;
         }
@@ -3572,7 +3572,7 @@ IcePy::TypedUpcall::validateException(PyObject* ex) const
 {
     for(ExceptionInfoList::const_iterator p = _op->exceptions.begin(); p != _op->exceptions.end(); ++p)
     {
-        if(PyObject_IsInstance(ex, (*p)->pythonType.get()))
+        if(PyObject_IsInstance(ex, (*p)->pythonType))
         {
             return true;
         }
diff --git a/src/Types.cpp b/src/Types.cpp
index f2072b8782..2efd2e5bd6 100644
--- a/src/Types.cpp
+++ b/src/Types.cpp
@@ -43,14 +43,6 @@ static ExceptionInfoMap _exceptionInfoMap;
 namespace IcePy
 {
 
-class InfoMapDestroyer
-{
-public:
-
-    ~InfoMapDestroyer();
-};
-static InfoMapDestroyer infoMapDestroyer;
-
 class ReadObjectCallback : public Ice::ReadObjectCallback
 {
 public:
@@ -140,6 +132,12 @@ extern "C"
 static void
 typeInfoDealloc(TypeInfoObject* self)
 {
+    //
+    // Every TypeInfo object is assigned to a "_t_XXX" variable in its enclosing module. Python releases these
+    // objects during shutdown, which gives us a chance to release resources and break cyclic references.
+    //
+    assert(self->info);
+    (*self->info)->destroy();
     delete self->info;
     Py_TYPE(self)->tp_free(reinterpret_cast<PyObject*>(self));
 }
@@ -1021,8 +1019,6 @@ IcePy::EnumInfo::EnumInfo(const string& ident, PyObject* t, PyObject* e) :
     assert(PyType_Check(t));
     assert(PyDict_Check(e));
 
-    Py_INCREF(t);
-
     Py_ssize_t pos = 0;
     PyObject* key;
     PyObject* value;
@@ -1056,7 +1052,7 @@ IcePy::EnumInfo::getId() const
 bool
 IcePy::EnumInfo::validate(PyObject* val)
 {
-    return PyObject_IsInstance(val, pythonType.get()) == 1;
+    return PyObject_IsInstance(val, pythonType) == 1;
 }
 
 bool
@@ -1128,10 +1124,16 @@ IcePy::EnumInfo::print(PyObject* value, IceUtilInternal::Output& out, PrintObjec
     out << getString(p.get());
 }
 
+void
+IcePy::EnumInfo::destroy()
+{
+    const_cast<EnumeratorMap&>(enumerators).clear();
+}
+
 Ice::Int
 IcePy::EnumInfo::valueForEnumerator(PyObject* p) const
 {
-    assert(PyObject_IsInstance(p, pythonType.get()) == 1);
+    assert(PyObject_IsInstance(p, pythonType) == 1);
 
     PyObjectHandle v = PyObject_GetAttrString(p, STRCAST("_value"));
     if(!v.get())
@@ -1194,7 +1196,7 @@ convertDataMembers(PyObject* members, DataMemberList& reqMembers, DataMemberList
     {
         PyObject* m = PyTuple_GET_ITEM(members, i);
         assert(PyTuple_Check(m));
-        assert(PyTuple_GET_SIZE(m) == allowOptional ? 5 : 3);
+        assert(PyTuple_GET_SIZE(m) == (allowOptional ? 5 : 3));
 
         PyObject* name = PyTuple_GET_ITEM(m, 0); // Member name.
         assert(checkString(name));
@@ -1269,8 +1271,6 @@ IcePy::StructInfo::StructInfo(const string& ident, PyObject* t, PyObject* m) :
     assert(PyType_Check(t));
     assert(PyTuple_Check(m));
 
-    Py_INCREF(t);
-
     DataMemberList opt;
     convertDataMembers(m, const_cast<DataMemberList&>(members), opt, false);
     assert(opt.empty());
@@ -1296,7 +1296,7 @@ IcePy::StructInfo::getId() const
 bool
 IcePy::StructInfo::validate(PyObject* val)
 {
-    return val == Py_None || PyObject_IsInstance(val, pythonType.get()) == 1;
+    return val == Py_None || PyObject_IsInstance(val, pythonType) == 1;
 }
 
 bool
@@ -1335,14 +1335,14 @@ void
 IcePy::StructInfo::marshal(PyObject* p, const Ice::OutputStreamPtr& os, ObjectMap* objectMap, bool optional,
                            const Ice::StringSeq*)
 {
-    assert(p == Py_None || PyObject_IsInstance(p, pythonType.get()) == 1); // validate() should have caught this.
+    assert(p == Py_None || PyObject_IsInstance(p, pythonType) == 1); // validate() should have caught this.
 
     if(p == Py_None)
     {
         if(!_nullMarshalValue.get())
         {
             PyObjectHandle args = PyTuple_New(0);
-            PyTypeObject* type = reinterpret_cast<PyTypeObject*>(pythonType.get());
+            PyTypeObject* type = reinterpret_cast<PyTypeObject*>(pythonType);
             _nullMarshalValue = type->tp_new(type, args.get(), 0);
             type->tp_init(_nullMarshalValue.get(), args.get(), 0); // Initialize the struct members
         }
@@ -1392,7 +1392,7 @@ void
 IcePy::StructInfo::unmarshal(const Ice::InputStreamPtr& is, const UnmarshalCallbackPtr& cb, PyObject* target,
                              void* closure, bool optional, const Ice::StringSeq*)
 {
-    PyObjectHandle p = instantiate(pythonType.get());
+    PyObjectHandle p = instantiate(pythonType);
     if(!p.get())
     {
         assert(PyErr_Occurred());
@@ -1458,15 +1458,8 @@ IcePy::StructInfo::print(PyObject* value, IceUtilInternal::Output& out, PrintObj
 void
 IcePy::StructInfo::destroy()
 {
-    for(DataMemberList::const_iterator p = members.begin(); p != members.end(); ++p)
-    {
-        (*p)->type->destroy();
-    }
     const_cast<DataMemberList&>(members).clear();
-    if(_nullMarshalValue.get())
-    {
-        _nullMarshalValue.release();
-    }
+    _nullMarshalValue = 0;
 }
 
 PyObject*
@@ -1736,11 +1729,7 @@ IcePy::SequenceInfo::print(PyObject* value, IceUtilInternal::Output& out, PrintO
 void
 IcePy::SequenceInfo::destroy()
 {
-    if(elementType)
-    {
-        elementType->destroy();
-        const_cast<TypeInfoPtr&>(elementType) = 0;
-    }
+    const_cast<TypeInfoPtr&>(elementType) = 0;
 }
 
 PyObject*
@@ -2406,7 +2395,7 @@ IcePy::CustomInfo::getId() const
 bool
 IcePy::CustomInfo::validate(PyObject* val)
 {
-    return PyObject_IsInstance(val, pythonType.get()) == 1;
+    return PyObject_IsInstance(val, pythonType) == 1;
 }
 
 bool
@@ -2437,7 +2426,7 @@ void
 IcePy::CustomInfo::marshal(PyObject* p, const Ice::OutputStreamPtr& os, ObjectMap* objectMap, bool,
                            const Ice::StringSeq* metaData)
 {
-    assert(PyObject_IsInstance(p, pythonType.get()) == 1); // validate() should have caught this.
+    assert(PyObject_IsInstance(p, pythonType) == 1); // validate() should have caught this.
 
     PyObjectHandle obj = PyObject_CallMethod(p, STRCAST("IsInitialized"), 0);
     if(!obj.get())
@@ -2488,7 +2477,7 @@ IcePy::CustomInfo::unmarshal(const Ice::InputStreamPtr& is, const UnmarshalCallb
         assert(PyErr_Occurred());
         throw AbortMarshaling();
     }
-    PyTypeObject* type = reinterpret_cast<PyTypeObject*>(pythonType.get());
+    PyTypeObject* type = reinterpret_cast<PyTypeObject*>(pythonType);
     PyObjectHandle p = type->tp_new(type, args.get(), 0);
     if(!p.get())
     {
@@ -2551,11 +2540,6 @@ IcePy::CustomInfo::print(PyObject* value, IceUtilInternal::Output& out, PrintObj
     }
 }
 
-void
-IcePy::CustomInfo::destroy()
-{
-}
-
 //
 // DictionaryInfo implementation.
 //
@@ -2783,16 +2767,8 @@ IcePy::DictionaryInfo::KeyCallback::unmarshaled(PyObject* val, PyObject*, void*)
 void
 IcePy::DictionaryInfo::destroy()
 {
-    if(keyType)
-    {
-        keyType->destroy();
-        keyType = 0;
-    }
-    if(valueType)
-    {
-        valueType->destroy();
-        valueType = 0;
-    }
+    keyType = 0;
+    valueType = 0;
 }
 
 //
@@ -2801,7 +2777,7 @@ IcePy::DictionaryInfo::destroy()
 IcePy::ClassInfo::ClassInfo(const string& ident) :
     id(ident), compactId(-1), isAbstract(false), preserve(false), defined(false)
 {
-    const_cast<PyObjectHandle&>(typeObj) = createType(this);
+    typeObj = createType(this);
 }
 
 void
@@ -2833,8 +2809,7 @@ IcePy::ClassInfo::define(PyObject* t, int compact, bool abstr, bool pres, PyObje
 
     convertDataMembers(m, const_cast<DataMemberList&>(members), const_cast<DataMemberList&>(optionalMembers), true);
 
-    const_cast<PyObjectHandle&>(pythonType) = t;
-    Py_INCREF(t);
+    pythonType = t;
 
     const_cast<bool&>(defined) = true;
 }
@@ -2848,7 +2823,7 @@ IcePy::ClassInfo::getId() const
 bool
 IcePy::ClassInfo::validate(PyObject* val)
 {
-    return val == Py_None || PyObject_IsInstance(val, pythonType.get()) == 1;
+    return val == Py_None || PyObject_IsInstance(val, pythonType) == 1;
 }
 
 bool
@@ -2879,7 +2854,7 @@ void
 IcePy::ClassInfo::marshal(PyObject* p, const Ice::OutputStreamPtr& os, ObjectMap* objectMap, bool,
                           const Ice::StringSeq*)
 {
-    if(!pythonType.get())
+    if(!pythonType)
     {
         PyErr_Format(PyExc_RuntimeError, STRCAST("class %s is declared but not defined"), id.c_str());
         throw AbortMarshaling();
@@ -2891,7 +2866,7 @@ IcePy::ClassInfo::marshal(PyObject* p, const Ice::OutputStreamPtr& os, ObjectMap
         return;
     }
 
-    if(!PyObject_IsInstance(p, pythonType.get()))
+    if(!PyObject_IsInstance(p, pythonType))
     {
         PyErr_Format(PyExc_ValueError, STRCAST("expected value of type %s"), id.c_str());
         throw AbortMarshaling();
@@ -2926,7 +2901,7 @@ void
 IcePy::ClassInfo::unmarshal(const Ice::InputStreamPtr& is, const UnmarshalCallbackPtr& cb, PyObject* target,
                             void* closure, bool, const Ice::StringSeq*)
 {
-    if(!pythonType.get())
+    if(!pythonType)
     {
         PyErr_Format(PyExc_RuntimeError, STRCAST("class %s is declared but not defined"), id.c_str());
         throw AbortMarshaling();
@@ -2988,16 +2963,7 @@ IcePy::ClassInfo::destroy()
 {
     const_cast<ClassInfoPtr&>(base) = 0;
     const_cast<ClassInfoList&>(interfaces).clear();
-    if(!members.empty())
-    {
-        DataMemberList ml = members;
-        const_cast<DataMemberList&>(members).clear();
-        for(DataMemberList::iterator p = ml.begin(); p != ml.end(); ++p)
-        {
-            (*p)->type->destroy();
-        }
-    }
-    const_cast<PyObjectHandle&>(typeObj) = 0; // Break circular reference.
+    const_cast<DataMemberList&>(members).clear();
 }
 
 void
@@ -3053,14 +3019,13 @@ IcePy::ClassInfo::printMembers(PyObject* value, IceUtilInternal::Output& out, Pr
 IcePy::ProxyInfo::ProxyInfo(const string& ident) :
     id(ident)
 {
-    const_cast<PyObjectHandle&>(typeObj) = createType(this);
+    typeObj = createType(this); // Borrowed reference.
 }
 
 void
 IcePy::ProxyInfo::define(PyObject* t)
 {
-    const_cast<PyObjectHandle&>(pythonType) = t;
-    Py_INCREF(t);
+    pythonType = t; // Borrowed reference.
 }
 
 string
@@ -3072,7 +3037,7 @@ IcePy::ProxyInfo::getId() const
 bool
 IcePy::ProxyInfo::validate(PyObject* val)
 {
-    return val == Py_None || PyObject_IsInstance(val, pythonType.get()) == 1;
+    return val == Py_None || PyObject_IsInstance(val, pythonType) == 1;
 }
 
 bool
@@ -3139,13 +3104,13 @@ IcePy::ProxyInfo::unmarshal(const Ice::InputStreamPtr& is, const UnmarshalCallba
         return;
     }
 
-    if(!pythonType.get())
+    if(!pythonType)
     {
         PyErr_Format(PyExc_RuntimeError, STRCAST("class %s is declared but not defined"), id.c_str());
         throw AbortMarshaling();
     }
 
-    PyObjectHandle p = createProxy(proxy, is->communicator(), pythonType.get());
+    PyObjectHandle p = createProxy(proxy, is->communicator(), pythonType);
     cb->unmarshaled(p.get(), target, closure);
 }
 
@@ -3174,12 +3139,6 @@ IcePy::ProxyInfo::print(PyObject* value, IceUtilInternal::Output& out, PrintObje
     }
 }
 
-void
-IcePy::ProxyInfo::destroy()
-{
-    const_cast<PyObjectHandle&>(typeObj) = 0; // Break circular reference.
-}
-
 //
 // ObjectWriter implementation.
 //
@@ -3411,27 +3370,6 @@ IcePy::ObjectReader::getSlicedData() const
     return _slicedData;
 }
 
-//
-// InfoMapDestroyer implementation.
-//
-IcePy::InfoMapDestroyer::~InfoMapDestroyer()
-{
-    {
-        for(ProxyInfoMap::iterator p = _proxyInfoMap.begin(); p != _proxyInfoMap.end(); ++p)
-        {
-            p->second->destroy();
-        }
-    }
-    {
-        for(ClassInfoMap::iterator p = _classInfoMap.begin(); p != _classInfoMap.end(); ++p)
-        {
-            p->second->destroy();
-        }
-    }
-    _compactIdMap.clear();
-    _exceptionInfoMap.clear();
-}
-
 //
 // ReadObjectCallback implementation.
 //
@@ -3459,7 +3397,7 @@ IcePy::ReadObjectCallback::invoke(const Ice::ObjectPtr& p)
         // Verify that the object's type is compatible with the formal type.
         //
         PyObject* obj = reader->getObject(); // Borrowed reference.
-        if(!PyObject_IsInstance(obj, _info->pythonType.get()))
+        if(!PyObject_IsInstance(obj, _info->pythonType))
         {
             Ice::UnexpectedObjectException ex(__FILE__, __LINE__);
             ex.reason = "unmarshaled object is not an instance of " + _info->id;
@@ -3482,7 +3420,7 @@ IcePy::ReadObjectCallback::invoke(const Ice::ObjectPtr& p)
 void
 IcePy::ExceptionInfo::marshal(PyObject* p, const Ice::OutputStreamPtr& os, ObjectMap* objectMap)
 {
-    if(!PyObject_IsInstance(p, pythonType.get()))
+    if(!PyObject_IsInstance(p, pythonType))
     {
         PyErr_Format(PyExc_ValueError, STRCAST("expected exception %s"), id.c_str());
         throw AbortMarshaling();
@@ -3561,7 +3499,7 @@ IcePy::ExceptionInfo::writeMembers(PyObject* p, const Ice::OutputStreamPtr& os,
 PyObject*
 IcePy::ExceptionInfo::unmarshal(const Ice::InputStreamPtr& is)
 {
-    PyObjectHandle p = createExceptionInstance(pythonType.get());
+    PyObjectHandle p = createExceptionInstance(pythonType);
 
     ExceptionInfoPtr info = this;
     while(info)
@@ -3604,7 +3542,7 @@ IcePy::ExceptionInfo::unmarshal(const Ice::InputStreamPtr& is)
 void
 IcePy::ExceptionInfo::print(PyObject* value, IceUtilInternal::Output& out)
 {
-    if(!PyObject_IsInstance(value, pythonType.get()))
+    if(!PyObject_IsInstance(value, pythonType))
     {
         out << "<invalid value - expected " << id << ">";
         return;
@@ -4248,10 +4186,13 @@ IcePy_declareProxy(PyObject*, PyObject* args)
     {
         info = new ProxyInfo(proxyId);
         addProxyInfo(proxyId, info);
+        return info->typeObj; // Delegate ownership to the global "_t_XXX" variable.
+    }
+    else
+    {
+        Py_INCREF(info->typeObj);
+        return info->typeObj;
     }
-
-    Py_INCREF(info->typeObj.get());
-    return info->typeObj.get();
 }
 
 extern "C"
@@ -4275,12 +4216,15 @@ IcePy_defineProxy(PyObject*, PyObject* args)
     {
         info = new ProxyInfo(proxyId);
         addProxyInfo(proxyId, info);
+        info->define(type);
+        return info->typeObj; // Delegate ownership to the global "_t_XXX" variable.
+    }
+    else
+    {
+        info->define(type);
+        Py_INCREF(info->typeObj);
+        return info->typeObj;
     }
-
-    info->define(type);
-
-    Py_INCREF(info->typeObj.get());
-    return info->typeObj.get();
 }
 
 extern "C"
@@ -4298,10 +4242,13 @@ IcePy_declareClass(PyObject*, PyObject* args)
     {
         info = new ClassInfo(id);
         addClassInfo(id, info);
+        return info->typeObj; // Delegate ownership to the global "_t_XXX" variable.
+    }
+    else
+    {
+        Py_INCREF(info->typeObj);
+        return info->typeObj;
     }
-
-    Py_INCREF(info->typeObj.get());
-    return info->typeObj.get();
 }
 
 extern "C"
@@ -4325,6 +4272,8 @@ IcePy_defineClass(PyObject*, PyObject* args)
 
     assert(PyTuple_Check(meta));
 
+    PyObject* r;
+
     //
     // A ClassInfo object will already exist for this id if a forward declaration
     // was encountered, or if the Slice definition is being reloaded. In the latter
@@ -4335,6 +4284,12 @@ IcePy_defineClass(PyObject*, PyObject* args)
     {
         info = new ClassInfo(id);
         addClassInfo(id, info);
+        r = info->typeObj; // Delegate ownership to the global "_t_XXX" variable.
+    }
+    else
+    {
+        Py_INCREF(info->typeObj);
+        r = info->typeObj;
     }
 
     info->define(type, compactId, isAbstract ? true : false, preserve ? true : false, base, interfaces, members);
@@ -4346,8 +4301,7 @@ IcePy_defineClass(PyObject*, PyObject* args)
     }
     _compactIdMap.insert(CompactIdMap::value_type(info->compactId, info));
 
-    Py_INCREF(info->typeObj.get());
-    return info->typeObj.get();
+    return r;
 }
 
 extern "C"
diff --git a/src/Types.h b/src/Types.h
index a19b0d6945..7efe055e13 100644
--- a/src/Types.h
+++ b/src/Types.h
@@ -197,11 +197,13 @@ class EnumInfo : public TypeInfo
 
     virtual void print(PyObject*, IceUtilInternal::Output&, PrintObjectHistory*);
 
+    virtual void destroy();
+
     Ice::Int valueForEnumerator(PyObject*) const;
     PyObject* enumeratorForValue(Ice::Int) const;
 
     const std::string id;
-    const PyObjectHandle pythonType;
+    PyObject* pythonType; // Borrowed reference - the enclosing Python module owns the reference.
     const Ice::Int maxValue;
     const EnumeratorMap enumerators;
 };
@@ -253,7 +255,7 @@ class StructInfo : public TypeInfo
 
     const std::string id;
     const DataMemberList members;
-    const PyObjectHandle pythonType;
+    PyObject* pythonType; // Borrowed reference - the enclosing Python module owns the reference.
 
 private:
 
@@ -348,10 +350,8 @@ class CustomInfo : public TypeInfo
 
     virtual void print(PyObject*, IceUtilInternal::Output&, PrintObjectHistory*);
 
-    virtual void destroy();
-
     const std::string id;
-    const PyObjectHandle pythonType;
+    PyObject* pythonType; // Borrowed reference - the enclosing Python module owns the reference.
 };
 typedef IceUtil::Handle<CustomInfo> CustomInfoPtr;
 
@@ -442,8 +442,8 @@ class ClassInfo : public TypeInfo
     const ClassInfoList interfaces;
     const DataMemberList members;
     const DataMemberList optionalMembers;
-    const PyObjectHandle pythonType;
-    const PyObjectHandle typeObj;
+    PyObject* pythonType; // Borrowed reference - the enclosing Python module owns the reference.
+    PyObject* typeObj; // Borrowed reference - the "_t_XXX" variable owns the reference.
     const bool defined;
 };
 
@@ -472,11 +472,9 @@ class ProxyInfo : public TypeInfo
 
     virtual void print(PyObject*, IceUtilInternal::Output&, PrintObjectHistory*);
 
-    virtual void destroy();
-
     const std::string id;
-    const PyObjectHandle pythonType;
-    const PyObjectHandle typeObj;
+    PyObject* pythonType; // Borrowed reference - the enclosing Python module owns the reference.
+    PyObject* typeObj; // Borrowed reference - the "_t_XXX" variable owns the reference.
 };
 typedef IceUtil::Handle<ProxyInfo> ProxyInfoPtr;
 
@@ -499,7 +497,7 @@ class ExceptionInfo : public IceUtil::Shared
     DataMemberList members;
     DataMemberList optionalMembers;
     bool usesClasses;
-    PyObjectHandle pythonType;
+    PyObject* pythonType; // Borrowed reference - the enclosing Python module owns the reference.
 
 private:
 
